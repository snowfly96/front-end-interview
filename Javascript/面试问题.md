###  :pen: 基础问题 

JavaScript是一种脚本语言，用于给文档添加各种复杂的行为，使得各种静态网页变成具有交互功能的动态网页。在JavaScript中没有多线程的概念，js是单线程的，使用异步机制来处理各类事件。

#### 1. js由哪三部分组成？

> **ECMAScript：**js的核心，用于描述javascript的语法
> **文档对象模型：**将html页面抽象成为一棵逻辑树，树中每个节点代表一个元素，提供给js访问操作树对象的接口
> **浏览器的对象模型：**用于控制浏览器行为的接口

#### 2. js的内存管理方式？

> 分配内存=>释放内存
>
> 创建变量的时候根据变量类型在对应的栈和堆中分配内存
> 局部作用域内的变量在函数完毕自动释放，堆栈内的对象重新赋值给null或者程序运行结束，关闭浏览器的时候自动释放

#### 3. 什么是变量/函数提升？

> **变量声明提升**
>
> 1. 通过var声明定义的变量，在定义之前都会被访问到
> 2. 提升属于声明提升，值为undefined，后续再进行赋值
>
> **函数声明提升**
>
> 1. 通过function声明的函数，在其之前就可以调用
> 2. 值：定义的函数对象

#### 4. let，const与var的区别？

> let与var
>
> 1. 作用域不同：let是块级作用域变量，var方法作用域变量
> 2. var存在变量提升问题，let不存在变量提升问题
> 3. let不允许变量重复声明，未声明使用则会报错
>
> const
>
> 常量声明，变量必须初始化，后面不能再修改值（实际上指向的内存地址不能修改）
> const 声明的变量保存的只是**栈内存**中的地址

#### 5. 可枚举和可迭代？

> 1. **可枚举：**决定对象中的属性能否通过for in遍历到
> 2. **可迭代：**拥有next方法，通过迭代器进行元素的顺序遍历访问

#### 6. instanceof与typeof区别？

> **instanceof**
>
> 1. 使用方法：“xxx” instanceof String
> 2. 返回值：布尔值
>
> instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
>
> **typeof**
>
> 1. 使用方法：typeof xxx 返回一个数据类型对象字符串
> 2. 不能区别：null和Object（“object”），Array和Object（“object”）
>
> 对null（object）无效，对function（function）有效

#### 7. null与undefined区别？

> **undefined**
>
> 1. undefined属于变量的生命，表示该变量后续会被使用，当下没有对其做任何操作
>
> **null**
>
> 1. 在声明变量的时候被赋值为null，为该变量占了一个坑，暗示即将被赋值为一个对象
> 2. 可以对不使用的对象进行内存回收

#### 8. 基本数据类型与引用数据类型赋值？

> **引用数据类型**
>
> 1. 采用引用方式，采用别名的方式指向同一块内存空间
> 2. 每个引用变量都可以修改指向的对象的值
> 3. 当其中一个引用变量被赋值新的对象时，该引用变量与原内存空间断开连接，另外的引用变量不受影响
>
> **基本数据类型**
>
> 1. 基本数据类型采用赋值的方式，变量修改值互不影响

#### 9. 函数调用的方法？

> 1. func() 直接调用
> 2. obj.func() 对象调用
> 3. new func() new创建实例调用
> 4. func.call(obj)/func.apply(obj)：修改this指向调用

#### 10. 立即执行函数？IIFE

> immediately invoked function expression
>
> 1. 隐藏实现，不会污染外部命名空间
> 2. 可以向外暴露一个全局函数

#### 11. 静态语言与动态语言？

> **静态语言和动态语言？**
>
> 1. **静态语言：**编译时变量的数据类型就可以确定的语言（C++/java等）
> 2. **动态语言：**运行时才确定数据类型的语言，变量使用之前无序声明类型（js/python等）
>
> Facebook的Flow允许js的静态类型检查
>
> **静态优点：**
>
> 1. 早发现错误
> 2. 减少错误处理
> 3. 减少bug
>
> **静态缺点：**
>
> 1. 代码冗长
> 2. 需要花时间掌握类型

#### 12. 静态作用域与动态作用域？

> 静态作用域：词法阶段就已经确定了
> 动态作用域：在程序执行的时候确定的

#### 13. promise和async await的区别？

> 1. **promise** 是为了解决**回调地狱**，但链式调用的 promise 同样让**代码纵向发展造成了代码冗余**
> 2. ES6 出现了生成器， **generator** 做异步处理返回iterator，但通过 next 方法去执行异步处理的每一段，使得**代码不易阅读**
> 3.  **async 函数是 generator 的语法糖**，用 async替换星号 ，用await替换yield； async 可以像普通函数一样执行且返回 promise 对象便于后续调用

#### 14. 类数组对象？

> 可以利用索引访问，并具有length属性的对象

#### 15. 原型与原型链？

> **万物皆对象**
>
> 1. 创建函数的时候，解析器会给函数添加一个prototype属性（显式原型），该属性默认指向一个空对象（**原型对象**）；
> 2. 利用构造函数构建的**实例对象**都可以通过__proto__属性（隐式原型）访问到构造函数的prototype属性；
>    也就是说构造函数的prototype和实例对象的__proto__指向的是同一个**原型对象**，该**原型对象**属于存放着构造函数的属性与方法，相当于一个公共的内存空间
> 3. **实例对象**也可以由自己的私有属性和方法，当实例对象在调用某个属性和方法的时候，在自己内部找不到，就会通过__proto__访问到其构造函数的**原型对象**，查看是否存在相应的属性和方法，如果没有，继续通过构造函数的原型对象的__proto__往上找，知道最后一个原型对像null，该过程构成原型链**实例对象的constructor方法指向构造函数**

#### 16. 闭包与闭包作用？

> **定义：**当一个嵌套的内部（子）函数引用外部（父）函数的变量，执行外部函数时就能产生闭包
> 可以通过浏览器的调试工具查看
>
> **理解一：**闭包是嵌套的内部函数
> **理解二：**闭包是被引用变量（函数）的对象
> **闭包的生命周期**
>
> 1. 产生：嵌套内部函数定义执行完毕之后就产生，不是调用时
> 2. 死亡：嵌套内部函数称为垃圾对象时，即外部的变量f=null不指向返回的闭包函数时
>
> **优点**
>
> 1. 使得变量在执行完后，仍然存在内存中（延长生命周期）
> 2. 使得外部函数可以操作函数内部变量（按特定方法，暴露操作接口，不暴露变量）
>
> **缺点**
>
> 1. 内存泄漏
> 2. 局部变量长时间占用内存，消耗内存资源
>
> **应用：定义JS模块**
>
> 1. 具有特定功能的模块
> 2. 将所有数据和功能封装在一个函数内部
> 3. 向外只暴露一些特定的函数/接口
> 4. 模块的使用者，只需要通过模块暴露的方法实现对应的功能

#### 17. 回调函数？

> **遵循原则：**
>
> 1. 自定义的函数
> 2. 自己没有调用
> 3. 最终被执行了
>
> **常见的回调函数：**
>
> 1. DOM事件回调
> 2. 定时器回调函数
> 3. ajax异步请求回调
> 4. 生命周期（钩子）函数回调

#### 18. js的this问题？

> **任何函数本质上都是通过某个对象调用的，**分为
>
> 1. 明确制定
> 2. 被动指定
>
>
> **this指向：**调用该函数的对象
>
> 1. 所有函数内部都有一个变量this
> 2. 它的值对应于调用对象
> 3. 不指定this则指向window

#### 19. 执行上下文问题？

> **代码分类**
>
> 1. 全局代码
> 2. 函数代码
>
> **全局执行上下文**
>
> 1. 执行全局代码之前将window确定为全局执行上下文对象
> 2. 对全局数据进行预处理
>    - 将var进行变量提升
>    - 将function进行变量提升
>    - 将this赋值该window
>
> **函数执行上下文**
>
> 1. 在调用函数，准备执行之前，创建一个函数上下文对象
> 2. 对局部变量进行预处理
>    - 形式参数->赋值给实际参数->添加到函数上下文
>    - var声明的变量提升，添加...
>    - function函数声明提升，添加...
>    - arguments赋值给实际参数列表，添加...
>    - this指向调用函数的对象
>
> **执行上下文栈**
>
> 1. 全局代码执行之前，JS引擎会创建一个栈来管理上下文对象
> 2. 全局执行上下文window确定后，添加到栈中
> 3. 函数执行上下文确定之后，添加到栈中
> 4. 最内层函数执行完毕之后，函数执行上下文依次出栈
> 5. 当所有代码执行完毕之后，全局执行上下文window对象出栈

#### 20. 作用域问题？

> 1. 执行上下文是代码执行后产生的，属于动态的
> 2. 作用域在编写代码的时候就确定了，属于静态的
>
> 隔离变量，不同作用域下的变量互不影响
> \------------
> var x=10;
>
> function fn(x) {console.log(x);}
> function show(f) {
>
> ​	var x=20
>
> ​	f()  }
>
> show(fn) // 输出10，代码执行前确定的

#### 21. js的异步机制？

> 采用一个执行栈和一个任务队列来完成异步操作，所有同步操作在主线程上进行执行，执行完成之后从任务队列中取出各种事件回调的异步任务进行执行

#### 22. 宏任务与微任务？

> 消息队列中的任务通常存储着宏任务，比如I/O，setTimeOut，setInterval等
>
> 微任务如：promise.then等

#### 23. js的内存泄漏情况？

> 1. 意外的全局变量
> 2. 闭包
> 3. 未被清空的定时器
> 4. 未被销毁的事件监听
> 5. DOM 引用

#### 24. js的单线程？

> js代码分为**初始化代码和回调代码**
> 回调代码放入分线程中，等初始化代码在主线程中执行完毕之后才通过消息队列和事件查询送到主线程中执行
>
> **事件循环模型**
>
> 1. 创建worker对象
> 2. 该方法存在不能访问DOM和部分浏览器不支持问题

#### 25. js的定时器？

> 定时器定时执行么？
>
> 1. 一般会延迟，也可能延迟较长时间
> 2. 需要了解JS的单线程机制和消息队列

#### 26. 防抖与节流？

> **防抖函数
> **事件响应函数在一段时间后再执行，如果函数在这段时间再次被调用，计时器清零，重新计算执行时间
>
> 1. scroll滚动事件
> 2. 搜索框输入查询
> 3. 表单查询
> 4. 按钮提交
> 5. 浏览器缩放等
>
> **节流函数**
>
> 1. mousemove事件
> 2. 搜索联想 
> 3. DOM的拖拽
> 4. 页面滚动与自动加载

#### 27. ajax的原理？

> **原理：在不加载整个网页的情况下，通过异步操作与服务器交换数据来更新页面内容**
> 通过XMLHttpRequest对象向服务器发送异步请求，然后从服务器上拿到数据，最后通过JS操作DOM更新页面
>
> 1. 创建XMLHttpRequest对象 xml
> 2. 通过xml中的open()方法与服务器建立连接
> 3. 构建请求所需要的数据，通过xml对象的send()方法发送给服务器
> 4. 通过xml对象的onreadstateChange事件监听服务器的和客户端通信状态
> 5. 接受并处理服务器响应的数据

#### 28. map与forEach的区别？

> **相同点**
>
> 1. 都是循环遍历数组中的每一项
> 2. 每次执行匿名函数都支持三个函数
> 3. 匿名函数中的this指向window
>
> **不同点**
>
> 1. map返回新数组
> 2. forEach运行callback更改原始数组

#### 29. 什么是可迭代对象？

> ES6新增语法，仅限于迭代器；可迭代的对象Array, Map, Set, String, TypedArray, arguments等



#### 30. \==与===区别

> ==需要将左右两边的值转换为同一类型再进行比较
>
> + 会先判断是否在对比null 和undefined ，是的话就返回true.
> + 判断两者类型是否为string 和number，是的话就会将字符串**转换**为number.
>
> ===类型不同直接返回false
>
> false==‘’‘’返回true



#### 31. js的发布与订阅模式？chatgpt

> js的发布订阅模式是一种常见的事件处理机制，订阅者可以订阅某一个主题，并在主题有更新的时候接受通知
>
> 发布订阅步骤：
>
> 1. 定义主题：定义一个主题对象，并保存订阅者列表。主题对象可以提供订阅和取消订阅的方法。
> 2. 定义订阅者：定义一个订阅者对象，并实现 `update()` 方法来接收更新通知。
> 3. 创建主题和订阅者，并进行订阅
> 4. 发布更新：当主题有更新时，调用 `notifyObservers()` 方法通知所有订阅者。



#### 32. 观察者与被观察者？chatgpt

> 观察者模式（Observer Pattern）是一种常见的设计模式，也称为发布-订阅模式。该模式定义了一种一对多的关系，使得当一个对象的状态发生改变时，所有依赖它的对象都能够自动收到通知并进行相应的更新。
>
> 在 JavaScript 中，观察者模式的实现通常涉及两个主要角色：观察者和被观察者。被观察者维护一组观察者，并且提供添加、删除、通知观察者的方法。观察者则负责接收被观察者的通知，并进行相应的操作。



#### 33. js事件冒泡机制？chatgpt

> 事件冒泡（Event Bubbling）是指当一个元素上的事件被触发时，它会先被该元素自身处理，然后逐级向上传递给该元素的祖先元素，直到被文档中的根元素处理为止。这个过程就像气泡从水底逐渐上升到水面一样，因此称为“冒泡”。例如：
>
> <div id="outer">
>   <div id="inner">
>     <button id="button">Click me</button>
>   </div>
> </div>
>
> 如果点击按钮元素，点击事件会按照如下顺序触发：
>
> 1. `button` 元素触发点击事件。
> 2. 事件向父元素 `inner` 冒泡，触发 `inner` 的点击事件。
> 3. 事件继续向父元素 `outer` 冒泡，触发 `outer` 的点击事件。
> 4. 事件最终冒泡到文档对象，触发文档对象的点击事件。
>
> 在事件冒泡中，可以使用 `event.target` 属性来获取触发事件的元素，也可以使用 `event.currentTarget` 属性来获取当前正在处理事件的元素（即注册了事件监听器的元素）。可以通过在事件监听器中调用 `event.stopPropagation()` 方法来停止事件冒泡，即在当前元素上处理事件而不继续向上冒泡。
>
> ```js
> button.addEventListener("click",function (event) {
>   if (event.stopPropagation) {
>     event.stopPropagation()
>   }else{
>     event.cancelBubble=true
>   }
>   console.log("button click");
> })
> ```



#### 34. getUTCDate()和getDate()差别

> getUTCDate()返回Date全球标准时间的UTC表示的日期
>
> getDate()返回的是本地时间的表示的日期
